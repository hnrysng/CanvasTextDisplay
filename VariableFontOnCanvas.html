<html>
  <head>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        /* background-color: antiquewhite; */
        background-color: #222222;
        color: white;
        display: flex;
        justify-content: center;
      }

      canvas {
        /* display: block; */
        margin: auto;
        width: 500px;
      }

    </style>
  </head>

  <body>

    <div id="container"></div>

    <canvas id="canvas" width="1000" height="1000"></canvas>
    
    
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 15 XXThin_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 16 XXThin Italic_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 25 XThin_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 26 XThin Italic_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 35 Thin_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 36 Thin Italic_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 45 Light_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 46 Light Italic_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 55 Roman_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 56 Roman Italic_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 65 Medium_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 66 Medium Italic_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 75 Bold_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 76 Bold Italic_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 95 Black_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 96 Black Italic_data.js"></script>
    <script>


        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;
        ctx.webkitImageSmoothingEnabled = true;
        ctx.mozImageSmoothingEnabled = true;
        ctx.msImageSmoothingEnabled = true;
        ctx.oImageSmoothingEnabled = true;


        



        function VariableFontOnCanvas(typeface, letter, assets){

            let defaults = {
                position: { x: 0, y: 0 },
                weight: 0,
                scale: 1,
                alignment: "left",
                sticky: "top",
                color: "#ffffff",
                line_height: 1,
                tracking: 0,
                kerning: 0,
                stroke_width: 0,
                stroke_style: "#ffffff",
                structure_width: 0,
                structure_style: "#ffffff"
            };

            
            for (const prop in defaults) {
                if (assets[prop] === undefined) {
                    assets[prop] = defaults[prop];
                }
            }
            


            

            
            //  finding the unicode of the each letter
            let unicode_con = [];


            for(let i = 0; i < letter.length; i++){
                for(let j = 0; j < Object.entries(typeface[0].letters.info).length; j++){
                    if(letter[i].charCodeAt() == typeface[0].letters.info[j].unicode){
                        unicode_con[i] = j;
                    }
                }
            }




            //  organizing the info
            let typeface_path_con = [];
            let typeface_info_con = [];

            for(let i = 0; i < letter.length; i++){
                typeface_path_con[i] = [];
                typeface_info_con[i] = [];
                for(let j = 0; j < typeface.length; j++){
                    typeface_path_con[i][j] = [];
                    typeface_info_con[i][j] = [];
                }
            }

            for(let i = 0; i < letter.length; i++){
                for(let j = 0; j < typeface.length; j++){
                    typeface_path_con[i][j] = typeface[j].letters.path[unicode_con[i]];
                    typeface_info_con[i][j] = typeface[j].letters.info[unicode_con[i]];
                }
            }


            let letter_path_con = [];

            for(let i = 0; i < letter.length; i++){
                letter_path_con[i] = structuredClone(typeface_path_con[i][assets.weight]);
            }


            
            let structure_con = [];
            let structure_max_con = [];
            let structure_min_con;

            for(let i = 0; i < letter.length; i++){
                structure_con[i] = [];
                structure_max_con[i] = [];
            }


            for(let i = 0; i < letter.length; i++){
                structure_con[i] = {
                    point_0: {x: 0, y: 0}, 
                    point_1: {x: typeface_info_con[i][0].advanceWidth, y: 0}, 
                    point_2: {x: typeface_info_con[i][0].advanceWidth, y: -(typeface[0].parameters.descender - typeface[0].parameters.ascender)}, 
                    point_3: {x: 0, y: -(typeface[0].parameters.descender - typeface[0].parameters.ascender)},
                            
                    base_0: {x: 0, y:  typeface[0].parameters.ascender},
                    base_1: {x: typeface_info_con[i][0].advanceWidth, y : typeface[0].parameters.ascender}
                }
            }

            for(let i = 0; i < letter.length; i++){
                structure_max_con[i] = {
                    point_0: {x: 0, y: 0}, 
                    point_1: {x: typeface_info_con[i][1].advanceWidth, y: 0}, 
                    point_2: {x: typeface_info_con[i][1].advanceWidth, y: -(typeface[1].parameters.descender - typeface[1].parameters.ascender)}, 
                    point_3: {x: 0, y: -(typeface[1].parameters.descender - typeface[1].parameters.ascender)},
                            
                    base_0: {x: 0, y:  typeface[1].parameters.ascender},
                    base_1: {x: typeface_info_con[i][1].advanceWidth, y : typeface[1].parameters.ascender}
                }
            }

            structure_min_con = structuredClone(structure_con);






            let width_con = [];


            let updated_width_con = [];
            // let scale_con = [];
            // let weight_con = [];
            // let scale_con = [];
            // let weight_con = [];
            let letter_pos_con = [];
            let pos_y_align = [];

            for(let i = 0; i < letter.length; i++){
                updated_width_con[i] = 0;
                // scale_con[i] = assets.scale;
                // weight_con[i] = assets.weight;
                letter_pos_con[i] = {x:0, y:0};
            }


        


            this.draw = function(updated_weight){

                if(updated_weight == undefined){
                    updated_weight = assets.weight
                }


                let total_width = sumArray(width_con);


                 // might be able to take out of draw function if scale don't change in motion
                 if(assets.alignment == 'center'){
                    for(let i = 0; i < letter.length; i++){
                        text_alignment = assets.position.x - (total_width / 2);
                    }
                }else if(assets.alignment == 'left'){
                    for(let i = 0; i < letter.length; i++){
                        text_alignment = assets.position.x;
                    }
                }else if(assets.alignment == 'right'){
                    for(let i = 0; i < letter.length; i++){
                        text_alignment = assets.position.x - total_width;
                    }
                }

                


                // might be able to take out of draw function if scale don't change in motion
                if(assets.sticky == 'bottom'){
                    for(let i = 0; i < letter.length; i++){
                        pos_y_align[i] = - ((typeface[0].parameters.ascender - typeface[0].parameters.descender) * scale_con[i]);
                    }
                }else{
                    for(let i = 0; i < letter.length; i++){
                        pos_y_align[i] = 0;
                    }
                }



                for(let i = 0; i < structure_con.length; i++){

                    structure_con[i].point_0.x = structure_min_con[i].point_0.x + ((structure_max_con[i].point_0.x - structure_min_con[i].point_0.x) *  updated_weight);
                    structure_con[i].point_0.y = structure_min_con[i].point_0.y + ((structure_max_con[i].point_0.y - structure_min_con[i].point_0.y) *  updated_weight);

                    structure_con[i].point_1.x = structure_min_con[i].point_1.x + ((structure_max_con[i].point_1.x - structure_min_con[i].point_1.x) *  updated_weight);
                    structure_con[i].point_1.y = structure_min_con[i].point_1.y + ((structure_max_con[i].point_1.y - structure_min_con[i].point_1.y) *  updated_weight);

                    structure_con[i].point_2.x = structure_min_con[i].point_2.x + ((structure_max_con[i].point_2.x - structure_min_con[i].point_2.x) *  updated_weight);
                    structure_con[i].point_2.y = structure_min_con[i].point_2.y + ((structure_max_con[i].point_2.y - structure_min_con[i].point_2.y) *  updated_weight);

                    structure_con[i].point_3.x = structure_min_con[i].point_3.x + ((structure_max_con[i].point_3.x - structure_min_con[i].point_3.x) *  updated_weight);
                    structure_con[i].point_3.y = structure_min_con[i].point_3.y + ((structure_max_con[i].point_3.y - structure_min_con[i].point_3.y) *  updated_weight);


                    structure_con[i].base_0.x = structure_min_con[i].base_0.x + ((structure_max_con[i].base_0.x - structure_min_con[i].base_0.x) *  updated_weight);
                    structure_con[i].base_0.y = structure_min_con[i].base_0.y + ((structure_max_con[i].base_0.y - structure_min_con[i].base_0.y) *  updated_weight);

                    structure_con[i].base_1.x = structure_min_con[i].base_1.x + ((structure_max_con[i].base_1.x - structure_min_con[i].base_1.x) *  updated_weight);
                    structure_con[i].base_1.y = structure_min_con[i].base_1.y + ((structure_max_con[i].base_1.y - structure_min_con[i].base_1.y) *  updated_weight);
                    
                }



                for(let i = 0; i < letter.length; i++){
                    letter_pos_con[i] = {x: structure_con[i].point_1.x - structure_con[i].point_0.x, y: structure_con[i].point_3.y/2};
                }

                
                for(let i = 0; i < structure_con.length; i++){
                    width_con[i] = (structure_con[i].point_1.x - structure_con[i].point_0.x) * assets.scale;
                }


                // Variable to store the cumulative sum
                let cumulativeSum = 0;

                // Loop through the original array starting from index 1
                for (let i = 0; i < width_con.length; i++) {
                    cumulativeSum += width_con[i];
                    updated_width_con[i + 1] = cumulativeSum;
                }




                if(assets.structure_width !== 0){

                    for(let i = 0; i < structure_con.length; i++){
                        ctx.beginPath();
                        ctx.moveTo((structure_con[i].point_0.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_con[i].point_0.y * assets.scale) + assets.position.y + pos_y_align[i]);
                        ctx.lineTo((structure_con[i].point_1.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_con[i].point_1.y * assets.scale) + assets.position.y + pos_y_align[i]);
                        ctx.lineTo((structure_con[i].point_2.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_con[i].point_2.y * assets.scale) + assets.position.y + pos_y_align[i]);
                        ctx.lineTo((structure_con[i].point_3.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_con[i].point_3.y * assets.scale) + assets.position.y + pos_y_align[i]);
                        
                        ctx.lineTo((structure_con[i].point_0.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_con[i].point_0.y * assets.scale) + assets.position.y + pos_y_align[i]);

                        ctx.strokeStyle = assets.structure_style;
                        ctx.lineWidth = assets.structure_width;
                        ctx.stroke();

                        ctx.closePath();


                        ctx.beginPath();
                        ctx.moveTo((structure_con[i].base_0.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_con[i].base_0.y * assets.scale) + assets.position.y + pos_y_align[i]);
                        ctx.lineTo((structure_con[i].base_1.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_con[i].base_1.y * assets.scale) + assets.position.y + pos_y_align[i]);

                        ctx.strokeStyle = assets.structure_style;
                        ctx.lineWidth = assets.structure_width;
                        ctx.stroke();

                        ctx.closePath();

                    }

                }

                // ---------------------------------------------------------------------------------------------------------------------------------- //

                for(let i = 0; i < letter_path_con.length; i++){
                    for(let j = 0; j < letter_path_con[i].length; j++){
                        for(let k = 0; k < letter_path_con[i][j].length; k++){
                            letter_path_con[i][j][k].x = typeface_path_con[i][0][j][k].x + ((typeface_path_con[i][1][j][k].x - typeface_path_con[i][0][j][k].x) * updated_weight);
                            letter_path_con[i][j][k].y = typeface_path_con[i][0][j][k].y + ((typeface_path_con[i][1][j][k].y - typeface_path_con[i][0][j][k].y) * updated_weight);
                            letter_path_con[i][j][k].in_x = typeface_path_con[i][0][j][k].in_x + ((typeface_path_con[i][1][j][k].in_x - typeface_path_con[i][0][j][k].in_x) * updated_weight);
                            letter_path_con[i][j][k].in_y = typeface_path_con[i][0][j][k].in_y + ((typeface_path_con[i][1][j][k].in_y - typeface_path_con[i][0][j][k].in_y) * updated_weight);
                            letter_path_con[i][j][k].out_x = typeface_path_con[i][0][j][k].out_x + ((typeface_path_con[i][1][j][k].out_x - typeface_path_con[i][0][j][k].out_x) * updated_weight);
                            letter_path_con[i][j][k].out_y = typeface_path_con[i][0][j][k].out_y + ((typeface_path_con[i][1][j][k].out_y - typeface_path_con[i][0][j][k].out_y) * updated_weight);
                        }
                    }
                }




                
                ctx.beginPath();

                
                for(let i = 0; i < letter_path_con.length; i++){
                    for(let j = 0; j < letter_path_con[i].length; j++){

                            ctx.moveTo((letter_path_con[i][j][0].x * assets.scale) + updated_width_con[i] + text_alignment, ((-letter_path_con[i][j][0].y + typeface[0].parameters.ascender) * assets.scale) + assets.position.y + pos_y_align[i]); 

                            for(let k = 0; k < letter_path_con[i][j].length - 1; k++){
                                ctx.bezierCurveTo(
                                    (letter_path_con[i][j][k].out_x * assets.scale) + updated_width_con[i] + text_alignment, ((-letter_path_con[i][j][k].out_y + typeface[0].parameters.ascender) * assets.scale) + assets.position.y + pos_y_align[i],
                                    (letter_path_con[i][j][k + 1].in_x * assets.scale) + updated_width_con[i] + text_alignment, ((-letter_path_con[i][j][k + 1].in_y + typeface[0].parameters.ascender) * assets.scale) + assets.position.y + pos_y_align[i],
                                    (letter_path_con[i][j][k + 1].x * assets.scale) + updated_width_con[i] + text_alignment, ((-letter_path_con[i][j][k + 1].y + typeface[0].parameters.ascender) * assets.scale) + assets.position.y + pos_y_align[i]
                                );
                            }

                            ctx.bezierCurveTo(
                                (letter_path_con[i][j][letter_path_con[i][j].length - 1].out_x * assets.scale) + updated_width_con[i] + text_alignment, ((-letter_path_con[i][j][letter_path_con[i][j].length - 1].out_y + typeface[0].parameters.ascender) * assets.scale) + assets.position.y + pos_y_align[i],
                                (letter_path_con[i][j][0].in_x * assets.scale) + updated_width_con[i] + text_alignment, ((-letter_path_con[i][j][0].in_y + typeface[0].parameters.ascender) * assets.scale) + assets.position.y + pos_y_align[i],
                                (letter_path_con[i][j][0].x * assets.scale) + updated_width_con[i] + text_alignment, ((-letter_path_con[i][j][0].y + typeface[0].parameters.ascender) * assets.scale) + assets.position.y + pos_y_align[i]
                            );

                            ctx.lineTo((letter_path_con[i][j][0].x * assets.scale) + updated_width_con[i] + text_alignment, ((-letter_path_con[i][j][0].y + typeface[0].parameters.ascender) * assets.scale) + assets.position.y + pos_y_align[i]);

                    }
                }


                ctx.fillStyle = assets.color;
                ctx.fill();
                ctx.strokeStyle = assets.stroke_style;
                ctx.lineWidth = assets.stroke_width;
                ctx.stroke();
                ctx.closePath();

                
                
                
            }


            function sumArray(arr) {
                let sum = 0;

                for (let i = 0; i < arr.length; i++) {
                    sum += arr[i];
                }

                return sum;
            }
        

        }




        function VariableFontOnCanvas_1(typeface, assets, letter){




            let defaults = {
                position: { x: 0, y: 0 },
                weight: 0,
                scale: 1,
                alignment: "left",
                sticky: "top",
                color: "#ffffff",
                line_height: 1,
                tracking: 0,
                kerning: 0,
                stroke_width: 0,
                stroke_style: "#ffffff",
                structure_width: 0,
                structure_style: "#ffffff"
            };

            
            for (const prop in defaults) {
                if (assets[prop] === undefined) {
                    assets[prop] = defaults[prop];
                }
            }
            


            if (assets.typeface_italic) {
                console.log('its here')
            }

            console.log(assets.typeface_regular)

            
            //  finding the unicode of the each letter
            let unicode_con = [];


            for(let i = 0; i < letter.length; i++){
                for(let j = 0; j < Object.entries(typeface[0].letters.info).length; j++){
                    if(letter[i].charCodeAt() == typeface[0].letters.info[j].unicode){
                        unicode_con[i] = j;
                    }
                }
            }




            //  organizing the info
            let typeface_path_con = [];
            let typeface_info_con = [];

            for(let i = 0; i < letter.length; i++){
                typeface_path_con[i] = [];
                typeface_info_con[i] = [];
                for(let j = 0; j < typeface.length; j++){
                    typeface_path_con[i][j] = [];
                    typeface_info_con[i][j] = [];
                }
            }

            for(let i = 0; i < letter.length; i++){
                for(let j = 0; j < typeface.length; j++){
                    typeface_path_con[i][j] = typeface[j].letters.path[unicode_con[i]];
                    typeface_info_con[i][j] = typeface[j].letters.info[unicode_con[i]];
                }
            }


            let letter_path_con = [];

            for(let i = 0; i < letter.length; i++){
                letter_path_con[i] = structuredClone(typeface_path_con[i][assets.weight]);
            }


            
            let structure_con = [];
            let structure_max_con = [];
            let structure_min_con;

            for(let i = 0; i < letter.length; i++){
                structure_con[i] = [];
                structure_max_con[i] = [];
            }


            for(let i = 0; i < letter.length; i++){
                structure_con[i] = {
                    point_0: {x: 0, y: 0}, 
                    point_1: {x: typeface_info_con[i][0].advanceWidth, y: 0}, 
                    point_2: {x: typeface_info_con[i][0].advanceWidth, y: -(typeface[0].parameters.descender - typeface[0].parameters.ascender)}, 
                    point_3: {x: 0, y: -(typeface[0].parameters.descender - typeface[0].parameters.ascender)},
                            
                    base_0: {x: 0, y:  typeface[0].parameters.ascender},
                    base_1: {x: typeface_info_con[i][0].advanceWidth, y : typeface[0].parameters.ascender}
                }
            }

            for(let i = 0; i < letter.length; i++){
                structure_max_con[i] = {
                    point_0: {x: 0, y: 0}, 
                    point_1: {x: typeface_info_con[i][1].advanceWidth, y: 0}, 
                    point_2: {x: typeface_info_con[i][1].advanceWidth, y: -(typeface[1].parameters.descender - typeface[1].parameters.ascender)}, 
                    point_3: {x: 0, y: -(typeface[1].parameters.descender - typeface[1].parameters.ascender)},
                            
                    base_0: {x: 0, y:  typeface[1].parameters.ascender},
                    base_1: {x: typeface_info_con[i][1].advanceWidth, y : typeface[1].parameters.ascender}
                }
            }

            structure_min_con = structuredClone(structure_con);






            let width_con = [];


            let updated_width_con = [];
            let letter_pos_con = [];
            let pos_y_align = [];

            for(let i = 0; i < letter.length; i++){
                updated_width_con[i] = 0;
                letter_pos_con[i] = {x:0, y:0};
            }


        


            this.draw = function(variables){
// console.log(variables)
                if(variables.wdth == undefined){
                    variables.wdth = assets.weight
                }

                
                let total_width = sumArray(width_con);


                 // might be able to take out of draw function if scale don't change in motion
                 if(assets.alignment == 'center'){
                    for(let i = 0; i < letter.length; i++){
                        text_alignment = assets.position.x - (total_width / 2);
                    }
                }else if(assets.alignment == 'left'){
                    for(let i = 0; i < letter.length; i++){
                        text_alignment = assets.position.x;
                    }
                }else if(assets.alignment == 'right'){
                    for(let i = 0; i < letter.length; i++){
                        text_alignment = assets.position.x - total_width;
                    }
                }

                


                // might be able to take out of draw function if scale don't change in motion
                if(assets.sticky == 'bottom'){
                    for(let i = 0; i < letter.length; i++){
                        pos_y_align[i] = - ((typeface[0].parameters.ascender - typeface[0].parameters.descender) * scale_con[i]);
                    }
                }else{
                    for(let i = 0; i < letter.length; i++){
                        pos_y_align[i] = 0;
                    }
                }



                for(let i = 0; i < structure_con.length; i++){

                    structure_con[i].point_0.x = structure_min_con[i].point_0.x + ((structure_max_con[i].point_0.x - structure_min_con[i].point_0.x) *  variables.wdth);
                    structure_con[i].point_0.y = structure_min_con[i].point_0.y + ((structure_max_con[i].point_0.y - structure_min_con[i].point_0.y) *  variables.wdth);

                    structure_con[i].point_1.x = structure_min_con[i].point_1.x + ((structure_max_con[i].point_1.x - structure_min_con[i].point_1.x) *  variables.wdth);
                    structure_con[i].point_1.y = structure_min_con[i].point_1.y + ((structure_max_con[i].point_1.y - structure_min_con[i].point_1.y) *  variables.wdth);

                    structure_con[i].point_2.x = structure_min_con[i].point_2.x + ((structure_max_con[i].point_2.x - structure_min_con[i].point_2.x) *  variables.wdth);
                    structure_con[i].point_2.y = structure_min_con[i].point_2.y + ((structure_max_con[i].point_2.y - structure_min_con[i].point_2.y) *  variables.wdth);

                    structure_con[i].point_3.x = structure_min_con[i].point_3.x + ((structure_max_con[i].point_3.x - structure_min_con[i].point_3.x) *  variables.wdth);
                    structure_con[i].point_3.y = structure_min_con[i].point_3.y + ((structure_max_con[i].point_3.y - structure_min_con[i].point_3.y) *  variables.wdth);


                    structure_con[i].base_0.x = structure_min_con[i].base_0.x + ((structure_max_con[i].base_0.x - structure_min_con[i].base_0.x) *  variables.wdth);
                    structure_con[i].base_0.y = structure_min_con[i].base_0.y + ((structure_max_con[i].base_0.y - structure_min_con[i].base_0.y) *  variables.wdth);

                    structure_con[i].base_1.x = structure_min_con[i].base_1.x + ((structure_max_con[i].base_1.x - structure_min_con[i].base_1.x) *  variables.wdth);
                    structure_con[i].base_1.y = structure_min_con[i].base_1.y + ((structure_max_con[i].base_1.y - structure_min_con[i].base_1.y) *  variables.wdth);
                    
                }



                for(let i = 0; i < letter.length; i++){
                    letter_pos_con[i] = {x: structure_con[i].point_1.x - structure_con[i].point_0.x, y: structure_con[i].point_3.y/2};
                }

                
                for(let i = 0; i < structure_con.length; i++){
                    width_con[i] = (structure_con[i].point_1.x - structure_con[i].point_0.x) * assets.scale;
                }


                // Variable to store the cumulative sum
                let cumulativeSum = 0;

                // Loop through the original array starting from index 1
                for (let i = 0; i < width_con.length; i++) {
                    cumulativeSum += width_con[i];
                    updated_width_con[i + 1] = cumulativeSum;
                }




                if(assets.structure_width !== 0){

                    for(let i = 0; i < structure_con.length; i++){

                        ctx.beginPath();
                        ctx.moveTo((structure_con[i].point_0.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_con[i].point_0.y * assets.scale) + assets.position.y + pos_y_align[i]);
                        ctx.lineTo((structure_con[i].point_1.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_con[i].point_1.y * assets.scale) + assets.position.y + pos_y_align[i]);
                        ctx.lineTo((structure_con[i].point_2.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_con[i].point_2.y * assets.scale) + assets.position.y + pos_y_align[i]);
                        ctx.lineTo((structure_con[i].point_3.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_con[i].point_3.y * assets.scale) + assets.position.y + pos_y_align[i]);
                        
                        ctx.lineTo((structure_con[i].point_0.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_con[i].point_0.y * assets.scale) + assets.position.y + pos_y_align[i]);

                        ctx.strokeStyle = assets.structure_style;
                        ctx.lineWidth = assets.structure_width;
                        ctx.stroke();

                        ctx.closePath();


                        ctx.beginPath();
                        ctx.moveTo((structure_con[i].base_0.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_con[i].base_0.y * assets.scale) + assets.position.y + pos_y_align[i]);
                        ctx.lineTo((structure_con[i].base_1.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_con[i].base_1.y * assets.scale) + assets.position.y + pos_y_align[i]);

                        ctx.strokeStyle = assets.structure_style;
                        ctx.lineWidth = assets.structure_width;
                        ctx.stroke();

                        ctx.closePath();

                    }

                }

                // ---------------------------------------------------------------------------------------------------------------------------------- //

                for(let i = 0; i < letter_path_con.length; i++){
                    for(let j = 0; j < letter_path_con[i].length; j++){
                        for(let k = 0; k < letter_path_con[i][j].length; k++){

                            letter_path_con[i][j][k].x = typeface_path_con[i][0][j][k].x + ((typeface_path_con[i][1][j][k].x - typeface_path_con[i][0][j][k].x) * variables.wdth);
                            letter_path_con[i][j][k].y = typeface_path_con[i][0][j][k].y + ((typeface_path_con[i][1][j][k].y - typeface_path_con[i][0][j][k].y) * variables.wdth);
                            letter_path_con[i][j][k].in_x = typeface_path_con[i][0][j][k].in_x + ((typeface_path_con[i][1][j][k].in_x - typeface_path_con[i][0][j][k].in_x) * variables.wdth);
                            letter_path_con[i][j][k].in_y = typeface_path_con[i][0][j][k].in_y + ((typeface_path_con[i][1][j][k].in_y - typeface_path_con[i][0][j][k].in_y) * variables.wdth);
                            letter_path_con[i][j][k].out_x = typeface_path_con[i][0][j][k].out_x + ((typeface_path_con[i][1][j][k].out_x - typeface_path_con[i][0][j][k].out_x) * variables.wdth);
                            letter_path_con[i][j][k].out_y = typeface_path_con[i][0][j][k].out_y + ((typeface_path_con[i][1][j][k].out_y - typeface_path_con[i][0][j][k].out_y) * variables.wdth);

                        }
                    }
                }




                
                ctx.beginPath();

                
                for(let i = 0; i < letter_path_con.length; i++){
                    for(let j = 0; j < letter_path_con[i].length; j++){

                            ctx.moveTo((letter_path_con[i][j][0].x * assets.scale) + updated_width_con[i] + text_alignment, ((-letter_path_con[i][j][0].y + typeface[0].parameters.ascender) * assets.scale) + assets.position.y + pos_y_align[i]); 

                            for(let k = 0; k < letter_path_con[i][j].length - 1; k++){
                                ctx.bezierCurveTo(
                                    (letter_path_con[i][j][k].out_x * assets.scale) + updated_width_con[i] + text_alignment, ((-letter_path_con[i][j][k].out_y + typeface[0].parameters.ascender) * assets.scale) + assets.position.y + pos_y_align[i],
                                    (letter_path_con[i][j][k + 1].in_x * assets.scale) + updated_width_con[i] + text_alignment, ((-letter_path_con[i][j][k + 1].in_y + typeface[0].parameters.ascender) * assets.scale) + assets.position.y + pos_y_align[i],
                                    (letter_path_con[i][j][k + 1].x * assets.scale) + updated_width_con[i] + text_alignment, ((-letter_path_con[i][j][k + 1].y + typeface[0].parameters.ascender) * assets.scale) + assets.position.y + pos_y_align[i]
                                );
                            }

                            ctx.bezierCurveTo(
                                (letter_path_con[i][j][letter_path_con[i][j].length - 1].out_x * assets.scale) + updated_width_con[i] + text_alignment, ((-letter_path_con[i][j][letter_path_con[i][j].length - 1].out_y + typeface[0].parameters.ascender) * assets.scale) + assets.position.y + pos_y_align[i],
                                (letter_path_con[i][j][0].in_x * assets.scale) + updated_width_con[i] + text_alignment, ((-letter_path_con[i][j][0].in_y + typeface[0].parameters.ascender) * assets.scale) + assets.position.y + pos_y_align[i],
                                (letter_path_con[i][j][0].x * assets.scale) + updated_width_con[i] + text_alignment, ((-letter_path_con[i][j][0].y + typeface[0].parameters.ascender) * assets.scale) + assets.position.y + pos_y_align[i]
                            );

                            ctx.lineTo((letter_path_con[i][j][0].x * assets.scale) + updated_width_con[i] + text_alignment, ((-letter_path_con[i][j][0].y + typeface[0].parameters.ascender) * assets.scale) + assets.position.y + pos_y_align[i]);

                    }
                }


                ctx.fillStyle = assets.color;
                ctx.fill();
                ctx.strokeStyle = assets.stroke_style;
                ctx.lineWidth = assets.stroke_width;
                ctx.stroke();
                ctx.closePath();

                
                
                
            }


            function sumArray(arr) {
                let sum = 0;

                for (let i = 0; i < arr.length; i++) {
                    sum += arr[i];
                }

                return sum;
            }
        

        }


        let assets = {
                    position: {x: 100, y:100},
                    weight: 1,
                    scale: 0.1,
                    alignment: 'left',
                    italic: false,
                    sticky: undefined,
                    color: undefined,
                    line_height: undefined,
                    tracking: undefined,
                    kerning: undefined,
                    stroke_width: 1,
                    stroke_style: undefined,
                    structure_width: 1,
                    structure_style: undefined,
        }





        let typeface = [Neue_Haas_Grotesk_Display_Pro_15_XXThin, Neue_Haas_Grotesk_Display_Pro_95_Black]


        let letter_a_1 = new VariableFontOnCanvas(typeface, 'Hamburgefonstiv', assets);







        let typeface_1 = [
            {
                typeface: Neue_Haas_Grotesk_Display_Pro_15_XXThin,
                Weight: 0,
                Italic: 0,
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_15_XXThin,
                Weight: 100,
                Italic: 0,
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_25_XThin,
                Weight: 200,
                Italic: 0,
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_35_Thin,
                Weight: 300,
                Italic: 0,
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_45_Light,
                Weight: 400,
                Italic: 0,
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_55_Roman,
                Weight: 500,
                Italic: 0,
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_65_Medium,
                Weight: 600,
                Italic: 0,
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_75_Bold,
                Weight: 700,
                Italic: 0,
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_95_Black,
                Weight: 800,
                Italic: 0,
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_16_XXThin_Italic,
                Weight: 0,
                Italic: 100,
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_26_XThin_Italic,
                Weight: 0,
                Italic: 100,
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_36_Thin_Italic,
                Weight: 0,
                Italic: 100,
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_46_Light_Italic,
                Weight: 0,
                Italic: 100,
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_56_Roman_Italic,
                Weight: 0,
                Italic: 100,
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_66_Medium_Italic,
                Weight: 0,
                Italic: 100,
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_76_Bold_Italic,
                Weight: 0,
                Italic: 100,
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_96_Black_Italic,
                Weight: 0,
                Italic: 100,
            }
        ];



        let assets_1 = {
                    position: {x: 100, y:100},
                    weight: 0,
                    scale: 0.1,
                    alignment: 'left',
                    italic: false,
                    sticky: undefined,
                    color: undefined,
                    line_height: undefined,
                    tracking: undefined,
                    kerning: undefined,
                    stroke_width: 1,
                    stroke_style: undefined,
                    structure_width: 1,
                    structure_style: undefined,
        };


        let letter_a_2 = new VariableFontOnCanvas_1(typeface_1, assets_1, 'Hamburgefonstiv');


        


        function anim() {


            ctx.beginPath();
            ctx.rect(0, 0, 1000, 1000);
            ctx.fillStyle = "#000000";
            ctx.fill();
            ctx.closePath();

            // letter_a_1.draw(0.5);

            letter_a_2.draw({
                wdth: 0.5, 
                ital: 0.5
            })


            window.requestAnimationFrame(anim);


        }

        anim();





    </script>
  </body>
</html>
