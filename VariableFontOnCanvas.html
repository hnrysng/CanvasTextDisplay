<html>
  <head>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        /* background-color: antiquewhite; */
        background-color: #222222;
        color: white;
        display: flex;
        justify-content: center;
      }

      canvas {
        /* display: block; */
        margin: auto;
        width: 500px;
      }

    </style>
  </head>

  <body>

    <div id="container"></div>

    <canvas id="canvas" width="1000" height="1000"></canvas>
    
    
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 15 XXThin_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 16 XXThin Italic_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 25 XThin_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 26 XThin Italic_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 35 Thin_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 36 Thin Italic_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 45 Light_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 46 Light Italic_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 55 Roman_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 56 Roman Italic_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 65 Medium_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 66 Medium Italic_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 75 Bold_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 76 Bold Italic_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 95 Black_data.js"></script>
    <script src="assets/font_data/GlyphToCanvas/Neue Haas Grotesk Display Pro 96 Black Italic_data.js"></script>



    <script>

        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;
        ctx.webkitImageSmoothingEnabled = true;
        ctx.mozImageSmoothingEnabled = true;
        ctx.msImageSmoothingEnabled = true;
        ctx.oImageSmoothingEnabled = true;





        function VariableFontOnCanvas(variablefont, assets, text){


            let defaults = {
                position: { x: 0, y: 0 },
                weight: 0,
                scale: 1,
                alignment: "left",
                sticky: "top",
                color: "#ffffff",
                line_height: 1,
                tracking: 0,
                kerning: 0,
                stroke_width: 0,
                stroke_style: "#ffffff",
                structure_width: 0,
                structure_style: "#ffffff"
            };

            
            for (const prop in defaults) {
                if (assets[prop] === undefined) {
                    assets[prop] = defaults[prop];
                }
            }
                       
            
            let number_of_variables = Object.entries(variablefont[0].variables).length;

            //  Making infos and variables based on the selected letters
            function text_info(){

                
                //  finding the unicode of the each letter
                let unicode_con = [];


                for(let i = 0; i < text.length; i++){
                    for(let j = 0; j < Object.entries(variablefont[0].typeface.letters.info).length; j++){
                        if(text[i].charCodeAt() == variablefont[0].typeface.letters.info[j].unicode){
                            unicode_con[i] = j;
                        }
                    }
                }


                //  organizing the info
                let text_path_con = [];
                let text_info_con = [];
                let text_structure_con = [];

                for(let i = 0; i < variablefont.length; i++){
                    text_path_con[i] = [];
                    text_info_con[i] = [];
                    text_structure_con[i] = [];
                    // text_variables[i] = {variablefont[i].variables: {Weight: 0, Italic: 0}};
                    for(let j = 0; j < text.length; j++){
                        text_path_con[i][j] = [];
                        text_info_con[i][j] = [];
                        text_structure_con[i][j] = [];
                    }
                }

                for(let i = 0; i < variablefont.length; i++){
                    for(let j = 0; j < text.length; j++){
                        text_path_con[i][j] = variablefont[i].typeface.letters.path[unicode_con[j]];
                        text_info_con[i][j] = variablefont[i].typeface.letters.info[unicode_con[j]];
                        text_structure_con[i][j] = {
                            point_0: {x: 0, y: 0}, 
                            point_1: {x: text_info_con[i][j].advanceWidth, y: 0}, 
                            point_2: {x: text_info_con[i][j].advanceWidth, y: -(variablefont[i].typeface.parameters.descender - variablefont[i].typeface.parameters.ascender)}, 
                            point_3: {x: 0, y: -(variablefont[i].typeface.parameters.descender - variablefont[i].typeface.parameters.ascender)},
                                    
                            base_0: {x: 0, y:  variablefont[i].typeface.parameters.ascender},
                            base_1: {x: text_info_con[i][j].advanceWidth, y : variablefont[i].typeface.parameters.ascender}
                        }
                    }
                }

                // Might be cleaner to use this...
                let text_variables = variablefont.map(item => item.variables);;



                // what would be the best text format?
                
                return {text_variables, text_path_con, text_info_con, text_structure_con}

            }


            let text_package = text_info();




            let updated_width_con = [];
            let letter_pos_con = [];

            for(let i = 0; i < text.length; i++){
                updated_width_con[i] = 0;
                letter_pos_con[i] = {x:0, y:0};
            }


            let width_con = [];
            let pos_y_align = [];


        function interpolate(value1, value2, fraction) {
            return value1 + (value2 - value1) * fraction;
        }


        
        function findClosestPoints(text_package, input_variable) {
            let upper_con = {
                index: null,
                variable: null,
                path: null,
            };

            let lower_con = {
                index: null,
                variable: null,
                path: null,
            };


            for (let i = 0; i < text_package.text_variables.length; i++) {
                let variable_axes_val = text_package.text_variables[i];
                
                // Assume initially that variable_axes_val variable is both upper and lower bound
                let isUpper = true;
                let isLower = true;

                // Compare each key in the variable object
                for (let key in input_variable) {
                    if (variable_axes_val[key] < input_variable[key]) {
                        isUpper = false;
                    }else if (variable_axes_val[key] > input_variable[key]) {
                        isLower = false;
                    }else if (variable_axes_val[key] == input_variable[key] && input_variable[key] == 0) {
                        isUpper = false;
                    }else if (variable_axes_val[key] == input_variable[key]) {
                        isLower = false;
                    }
                    // console.log(variable_axes_val[key], variable[key])
                }

// console.log(variable)
                if (isUpper) {
                    if (upper_con.index == null || 
                        Object.entries(input_variable).some(([key, value]) =>
                            variable_axes_val[key] < upper_con.variable[key] ||
                            (variable_axes_val[key] === upper_con.variable[key] && variable_axes_val[key] < upper_con.variable[key])
                        )) {
                        upper_con.index = i;
                        upper_con.variable = variable_axes_val;
                        upper_con.path = text_package.text_path_con[i];
                    }
                }


                if (isLower) {
                    if (lower_con.index == null || 
                        Object.entries(input_variable).some(([key, value]) =>
                            variable_axes_val[key] > lower_con.variable[key] ||
                            (variable_axes_val[key] === lower_con.variable[key] && variable_axes_val[key] > lower_con.variable[key])
                        )) {
                        lower_con.index = i;
                        lower_con.variable = variable_axes_val;
                        lower_con.path = text_package.text_path_con[i];
                    }
                }
            }
            
            // console.log(variable, upper_con, lower_con)
            return { upper_con, lower_con };
            
        }




        function findClosestPoints_3(text_package, input_variable) {


            let number_of_variables = (Object.entries(text_package.text_variables[0]).length);
            
            
            let detector = structuredClone(text_package.text_variables);

            for (let i = 0; i < text_package.text_variables.length; i++) {
                for(let j = 0; j < number_of_variables; j++){

                    if(Object.entries(input_variable)[j][1] > Object.entries(text_package.text_variables[i])[j][1]){
                        detector[i][Object.keys(detector[i])[j]] = 'upper'
                    }else if(Object.entries(input_variable)[j][1] < Object.entries(text_package.text_variables[i])[j][1]){
                        detector[i][Object.keys(detector[i])[j]] = 'lower'
                    }else if(Object.entries(input_variable)[j][1] == Object.entries(text_package.text_variables[i])[j][1]){
                            
                    }

                }
            }

// console.log(detector)
// console.log(Object.entries(text_package.text_variables[0])[0][1])



            let test_collector = {lower: [], upper: []};

            for(let i = 0; i < number_of_variables; i++){
                test_collector.lower[i] = [];
                test_collector.upper[i] = [];
            }


            let test = [];


            let test_collector_1 = [];
            for(let i = 0; i < number_of_variables; i++){
                test_collector_1[i] = {lower: [], upper: []};;
            }


            let test_collector_2 = [];
            for(let i = 0; i < number_of_variables; i++){
                test_collector_2[i] = []
            }
            


            for (let i = 0; i < text_package.text_variables.length; i++) {
                for(let j = 0; j < number_of_variables; j++){

                    if(Object.entries(input_variable)[j][1] > Object.entries(text_package.text_variables[i])[j][1] 
                    && Object.entries(input_variable)[j][1] < Object.entries(text_package.text_variables[i + 1])[j][1]){

                        test_collector.lower[j].push({
                            index: i,
                            variable: text_package.text_variables[i],
                            path: text_package.text_path_con[i],
                        })

                        test_collector.upper[j].push({
                            index: i + 1,
                            variable: text_package.text_variables[i + 1],
                            path: text_package.text_path_con[i + 1],
                        })   


                        test_collector_1[j].lower.push({
                            index: i,
                            variable: text_package.text_variables[i],
                            path: text_package.text_path_con[i],
                        })

                        test_collector_1[j].upper.push({
                            index: i + 1,
                            variable: text_package.text_variables[i + 1],
                            path: text_package.text_path_con[i + 1],
                        })   



                        test_collector_2[j].push({
                            index: i,
                            variable: text_package.text_variables[i],
                            path: text_package.text_path_con[i],
                        })

                        test_collector_2[j].push({
                            index: i + 1,
                            variable: text_package.text_variables[i + 1],
                            path: text_package.text_path_con[i + 1],
                        })   
                    }

                }
            }


            let element_length_finder = [];

            for(let i = 0; i < number_of_variables; i++){
                element_length_finder.push(test_collector_1[i].lower.length + test_collector_1[i].upper.length)
            }

                        
            let mainIndex = element_length_finder.reduce((maxIndex, currentValue, currentIndex, arr) => {
                return currentValue > arr[maxIndex] ? currentIndex : maxIndex;
            }, 0);


            console.log(test_collector_1[mainIndex])
            console.log(test_collector_2[mainIndex])





            let test_mainAxisIndex = findLongestAndShortestSubArray(test_collector.lower).longestIndex;
            let test_notmainAxisIndex = findLongestAndShortestSubArray(test_collector.lower).shortestIndex;






            let axis_min_max_val_con = [];

            let collector = {lower: [], upper: []};

            for(let i = 0; i < number_of_variables; i++){

                collector.lower[i] = [];
                collector.upper[i] = [];

                axis_min_max_val_con[i] = {max: null, min:null};

            }

            
            
            let axis_min_max_detector = [];
    // console.log(detector)

            for (let i = 0; i < text_package.text_variables.length; i++) {
                for(let j = 0; j < number_of_variables; j++){
                    if(detector[i][Object.keys(detector[i])[j]] == 'upper' && detector[i+1][Object.keys(detector[i+1])[j]] == 'lower'){

                        collector.lower[j].push({
                            index: i,
                            variable: text_package.text_variables[i],
                            path: text_package.text_path_con[i],
                        })

                        collector.upper[j].push({
                            index: i + 1,
                            variable: text_package.text_variables[i + 1],
                            path: text_package.text_path_con[i + 1],
                        })   
console.log(j, i)
                        console.log(text_package.text_variables[i])

                    }
                }
            }
console.log(collector)

            function findLongestAndShortestSubArray(arr) {
                let maxLength = 0;
                let minLength = Infinity;
                let longestIndex = 0;
                let shortestIndex = 0;

                for (let i = 0; i < arr.length; i++) {
                    if (arr[i].length > maxLength) {
                    maxLength = arr[i].length;
                    longestIndex = i;
                    }
                    if (arr[i].length < minLength) {
                    minLength = arr[i].length;
                    shortestIndex = i;
                    }
                }

                return {
                    longestIndex: longestIndex,
                    shortestIndex: shortestIndex
                };
            }


            let mainAxisIndex = findLongestAndShortestSubArray(collector.lower).longestIndex;
            let notmainAxisIndex = findLongestAndShortestSubArray(collector.lower).shortestIndex;





            function findMinAndMaxVal(arr) {
                if (arr.length === 0) return { most: null, least: null };

                let maxVal = -Infinity;
                let minVal = Infinity;
                let maxIndex = -1;
                let minIndex = -1;

                arr.forEach((item, index) => {
                    if (item.variable && Object.entries(arr[index].variable)[notmainAxisIndex][1] !== undefined) {
                    if (Object.entries(arr[index].variable)[notmainAxisIndex][1] > maxVal) {
                        maxVal = Object.entries(arr[index].variable)[notmainAxisIndex][1];
                        maxIndex = index;
                    }
                    if (Object.entries(arr[index].variable)[notmainAxisIndex][1] < minVal) {
                        minVal = Object.entries(arr[index].variable)[notmainAxisIndex][1];
                        minIndex = index;
                    }
                    }
                });

                return {
                    min: arr[minIndex],
                    max: arr[maxIndex]
                };
            }

            





            let axis = {
                        lower: findMinAndMaxVal(collector.lower[mainAxisIndex]),
                        upper: findMinAndMaxVal(collector.upper[mainAxisIndex])
            };

            
console.log(axis.lower)
            for(let i = 0; i < axis; i++){
                axis
            }

            console.log(axis)
            console.log(axis_min_max_val_con)

            let vendingmachine = {
                machine_1: {min:{}, max:{}},
                machine_2: {}
            }

            
            console.log(collector.lower)
            console.log(collector)




            //if theres 3 variable axis
            //findMinandMaxVal should change
let test_input_val = {Weight: 350, Italic: 60, Width: 50}

let ideal_result = [
    {Weight: 300, Italic: 0, Width: 0}, {Weight: 300, Italic: 100, Width: 0}, {Weight: 300, Italic: 0, Width: 100}, {Weight: 300, Italic: 100, Width: 100},
    {Weight: 400, Italic: 0, Width: 0}, {Weight: 400, Italic: 100, Width: 0}, {Weight: 400, Italic: 0, Width: 100}, {Weight: 400, Italic: 100, Width: 100},
]



let collector_test = {
    lower: [
        [{variable:{Weight: 300, Italic: 0, Width: 0}}, {variable:{Weight: 300, Italic: 0, Width: 100}}, {variable:{Weight: 300, Italic: 100, Width: 0}}, {variable:{Weight: 300, Italic: 100, Width: 100}}],
        [{variable:{Weight: 700, Italic: 0, Width: 0}}, {variable:{Weight: 700, Italic: 0, Width: 100}}],
        [{variable:{Weight: 700, Italic: 0, Width: 0}}, {variable:{Weight: 700, Italic: 100, Width: 0}}]
    ], 
    upper: [
        [{variable:{Weight: 400, Italic: 0, Width: 0}}, {variable:{Weight: 400, Italic: 0, Width: 100}}, {variable:{Weight: 400, Italic: 100, Width: 0}}, {variable:{Weight: 400, Italic: 100, Width: 100}}],
        [{variable:{Weight: 0, Italic: 100, Width: 0}}, {variable:{Weight: 0, Italic: 100, Width: 100}}],
        [{variable:{Weight: 0, Italic: 0, Width: 100}}, {variable:{Weight: 0, Italic: 100, Width: 100}}]
    ]
}

console.log(findMinAndMaxVal(collector_test.lower[0]))
console.log(findMinAndMaxVal(collector_test.lower[1]))
console.log(collector)

            // [{min: 300, max:500}, {min:0, max:100}]

            return axis;

        }




        function findClosestPoints_2(text_package, input_variable) {


            let number_of_variables = (Object.entries(text_package.text_variables[0]).length);

            let axis_filter = [];
            let fraction_properties = [];
            let axis_val = [];
            let element_length_finder = [];

            for(let i = 0; i < number_of_variables; i++){
                axis_filter[i] = [];
                fraction_properties[i] = {min:null, max:null};
                axis_val[i] = [];
            }
            

            for (let i = 0; i < text_package.text_variables.length; i++) {
                for(let j = 0; j < number_of_variables; j++){

                    if(Object.entries(input_variable)[j][1] > Object.entries(text_package.text_variables[i])[j][1] 
                    && Object.entries(input_variable)[j][1] < Object.entries(text_package.text_variables[i + 1])[j][1]){

                        axis_filter[j].push({
                            index: i,
                            variable: text_package.text_variables[i],
                            path: text_package.text_path_con[i],
                        })


                        axis_filter[j].push({
                            index: i + 1,
                            variable: text_package.text_variables[i + 1],
                            path: text_package.text_path_con[i + 1],
                        })   

                    }

                }
            }



            for(let i = 0; i < number_of_variables; i++){
                element_length_finder.push(axis_filter[i].length)
            }


            let mainIndex = element_length_finder.reduce((maxIndex, currentValue, currentIndex, arr) => {
                return currentValue > arr[maxIndex] ? currentIndex : maxIndex;
            }, 0);


            let axis = axis_filter[mainIndex];



            for(let i = 0; i < axis_filter[mainIndex].length; i++){
                for(let j = 0; j < number_of_variables; j++){
                    axis_val[j].push(Object.entries(axis_filter[mainIndex][i].variable)[j][1])
                }
            }
            
            for(let i = 0; i < number_of_variables; i++){
                fraction_properties[i].min = Math.min(...axis_val[i]);
                fraction_properties[i].max = Math.max(...axis_val[i]);
            }



            function groupByKeysToArray(arr, keys) {
                let map = new Map();

                arr.forEach(item => {
                    let group = map;
                    keys.forEach((key, index) => {
                        const value = item.variable[key];
                        if (index === keys.length - 1) {
                            if (!group.has(value)) {
                                group.set(value, []);
                            }
                            group.get(value).push(item);
                        } else {
                            if (!group.has(value)) {
                                group.set(value, new Map());
                            }
                            group = group.get(value);
                        }
                    });
                });

                function mapToArray(map) {
                    let result = [];
                    map.forEach((value, key) => {
                        if (value instanceof Map) {
                            result = result.concat(mapToArray(value));
                        } else {
                            result.push(value);
                        }
                    });
                    return result;
                }

                return mapToArray(map);
            }



            let filter = [];

            for(let i = 0; i < number_of_variables - 1; i++){
                filter.push(Object.entries(axis[0].variable)[i][0])
            }




            let groupedaxis = groupByKeysToArray(axis, [filter]);



            let arr = [
                {index: 0, path: "something", variable: {Weight: 300, Italic: 0, Width: 0}}, 
                {index: 3, path: "something", variable: {Weight: 300, Italic: 100, Width: 0}}, 
                {index: 1, path: "something", variable: {Weight: 300, Italic: 0, Width: 100}}, 
                {index: 6, path: "something", variable: {Weight: 300, Italic: 100, Width: 100}},
                {index: 20, path: "something", variable: {Weight: 400, Italic: 0, Width: 0}}, 
                {index: 4, path: "something", variable: {Weight: 400, Italic: 100, Width: 0}}, 
                {index: 7, path: "something", variable: {Weight: 400, Italic: 0, Width: 100}}, 
                {index: 8, path: "something", variable: {Weight: 400, Italic: 100, Width: 100}},
            ];


            return {axis, groupedaxis, fraction_properties};

        }





        function calc_test(inputVariables){


            let variable_max_val_con = [];

            for(let i = 0; i < Object.entries(variblefont[0].variables).length; i++){
                variable_max_val_con[i] = 0;
            }

            for(let i = 0; i < variablefont.length; i++){
                for(let j = 0; j < Object.entries(variblefont[i].variables).length; j++){
                    if(Object.entries(variblefont[i].variables)[j][1] > variable_max_val_con[j]){
                        variable_max_val_con[j] = Object.entries(variblefont[i].variables)[j][1]
                    }
                }
            }
            
            for(let i = 0; i < variable_max_val_con.length; i++){
                if(inputVariables[Object.keys(inputVariables)[i]] > variable_max_val_con[i]){
                    inputVariables[Object.keys(inputVariables)[i]] = variable_max_val_con[i];
                }else if(inputVariables[Object.keys(inputVariables)[i]] < 0){
                    inputVariables[Object.keys(inputVariables)[i]] = 0;
                }
            }



            let { lower_con: lower, upper_con: upper } = findClosestPoints(text_package, inputVariables);


            if (!lower || !upper) {
                return null; // Or some default path value
            }




            let closet_axis = findClosestPoints_2(text_package, inputVariables)



            let fraction_con_1 = [];

            for (let i = 0; i < Object.entries(inputVariables).length; i++){
                fraction_con_1[i] = (Object.entries(inputVariables)[i][1] - closet_axis.fraction_properties[i].min) / (closet_axis.fraction_properties[i].max - closet_axis.fraction_properties[i].min);
            }



            console.log(fraction_con_1)
            console.log(closet_axis)
            console.log(closet_axis.groupedaxis);
            console.log(closet_axis.groupedaxis.length);



            let testest_con = [];

            for(let i = 0; i < closet_axis.groupedaxis.length; i++){
                testest_con[i] = structuredClone(closet_axis.axis[0].path);
            }



            if(testest_con.length !== 1){
                
            }


            for(let i = 0; i < closet_axis.groupedaxis.length; i++){
                for(let j = 0; j < closet_axis.groupedaxis[i].length; j++){
                    for(let k = 0; k < closet_axis.groupedaxis[i][0].path[j].length; k++){
                        for(let l = 0; l < closet_axis.groupedaxis[i][0].path[j][k].length; l++){

                            testest_con[i][j][k][l].x = interpolate(closet_axis.groupedaxis[i][0].path[j][k][l].x, closet_axis.groupedaxis[i][1].path[j][k][l].x, fraction_con_1[1]);
                            testest_con[i][j][k][l].y = interpolate(closet_axis.groupedaxis[i][0].path[j][k][l].y, closet_axis.groupedaxis[i][1].path[j][k][l].y, fraction_con_1[1]);
                            testest_con[i][j][k][l].in_x = interpolate(closet_axis.groupedaxis[i][0].path[j][k][l].in_x, closet_axis.groupedaxis[i][1].path[j][k][l].in_x, fraction_con_1[1]);
                            testest_con[i][j][k][l].in_y = interpolate(closet_axis.groupedaxis[i][0].path[j][k][l].in_y, closet_axis.groupedaxis[i][1].path[j][k][l].in_y, fraction_con_1[1]);
                            testest_con[i][j][k][l].out_x = interpolate(closet_axis.groupedaxis[i][0].path[j][k][l].out_x, closet_axis.groupedaxis[i][1].path[j][k][l].out_x, fraction_con_1[1]);
                            testest_con[i][j][k][l].out_y = interpolate(closet_axis.groupedaxis[i][0].path[j][k][l].out_y, closet_axis.groupedaxis[i][1].path[j][k][l].out_y, fraction_con_1[1]);

                            
                        }
                    }
                }
            }
            
            
            


            let tes_1 = {x:null, y:null, in_x:null, in_y:null, out_x:null, out_y:null}

            tes_1.x = interpolate(closet_axis.groupedaxis[0][0].path[1][0][0].x, closet_axis.groupedaxis[0][1].path[1][0][0].x, fraction_con_1[1]);
            tes_1.y = interpolate(closet_axis.groupedaxis[0][0].path[1][0][0].y, closet_axis.groupedaxis[0][1].path[1][0][0].y, fraction_con_1[1]);
            tes_1.in_x = interpolate(closet_axis.groupedaxis[0][0].path[1][0][0].in_x, closet_axis.groupedaxis[0][1].path[1][0][0].in_x, fraction_con_1[1]);
            tes_1.in_y = interpolate(closet_axis.groupedaxis[0][0].path[1][0][0].in_y, closet_axis.groupedaxis[0][1].path[1][0][0].in_y, fraction_con_1[1]);
            tes_1.out_x = interpolate(closet_axis.groupedaxis[0][0].path[1][0][0].out_x, closet_axis.groupedaxis[0][1].path[1][0][0].out_x, fraction_con_1[1]);
            tes_1.out_y = interpolate(closet_axis.groupedaxis[0][0].path[1][0][0].out_y, closet_axis.groupedaxis[0][1].path[1][0][0].out_y, fraction_con_1[1]);


            let tes_2 = {x:null, y:null, in_x:null, in_y:null, out_x:null, out_y:null}

            tes_2.x = interpolate(closet_axis.groupedaxis[1][0].path[1][0][0].x, closet_axis.groupedaxis[1][1].path[1][0][0].x, fraction_con_1[1]);
            tes_2.y = interpolate(closet_axis.groupedaxis[1][0].path[1][0][0].y, closet_axis.groupedaxis[1][1].path[1][0][0].y, fraction_con_1[1]);
            tes_2.in_x = interpolate(closet_axis.groupedaxis[1][0].path[1][0][0].in_x, closet_axis.groupedaxis[1][1].path[1][0][0].in_x, fraction_con_1[1]);
            tes_2.in_y = interpolate(closet_axis.groupedaxis[1][0].path[1][0][0].in_y, closet_axis.groupedaxis[1][1].path[1][0][0].in_y, fraction_con_1[1]);
            tes_2.out_x = interpolate(closet_axis.groupedaxis[1][0].path[1][0][0].out_x, closet_axis.groupedaxis[1][1].path[1][0][0].out_x, fraction_con_1[1]);
            tes_2.out_y = interpolate(closet_axis.groupedaxis[1][0].path[1][0][0].out_y, closet_axis.groupedaxis[1][1].path[1][0][0].out_y, fraction_con_1[1]);



            let tes_3 = {x:null, y:null, in_x:null, in_y:null, out_x:null, out_y:null}

            tes_3.x = interpolate(tes_1.x, tes_2.x, fraction_con_1[0])
            tes_3.y = interpolate(tes_1.y, tes_2.y, fraction_con_1[0])
            tes_3.in_x = interpolate(tes_1.in_x, tes_2.in_x, fraction_con_1[0])
            tes_3.in_y = interpolate(tes_1.in_y, tes_2.in_y, fraction_con_1[0])
            tes_3.out_x = interpolate(tes_1.out_x, tes_2.out_x, fraction_con_1[0])
            tes_3.out_y = interpolate(tes_1.out_y, tes_2.out_y, fraction_con_1[0])








            let text_path_to_draw_1 = structuredClone(closet_axis.axis[0].path);

  


            for(let x = 0; x < text_path_to_draw_1.length; x++){
                for (let i = 0; i < text_path_to_draw_1[x].length; i++) {
                    for (let j = 0; j < text_path_to_draw_1[x][i].length; j++) {
                        for (let k = 0; k < text_path_to_draw_1[x][i][j].length; k++) {
                        
                            text_path_to_draw_1[x][i][j][k].x = interpolate(lower.path[i][j][k].x, upper.path[i][j][k].x, fraction_con[x]);
                            text_path_to_draw_1[x][i][j][k].y = interpolate(lower.path[i][j][k].y - variablefont[0].typeface.parameters.ascender, upper.path[i][j][k].y - variablefont[0].typeface.parameters.ascender, fraction_con[x]);
                            text_path_to_draw_1[x][i][j][k].in_x = interpolate(lower.path[i][j][k].in_x, upper.path[i][j][k].in_x, fraction_con[x]);
                            text_path_to_draw_1[x][i][j][k].in_y = interpolate(lower.path[i][j][k].in_y - variablefont[0].typeface.parameters.ascender, upper.path[i][j][k].in_y - variablefont[0].typeface.parameters.ascender, fraction_con[x]);
                            text_path_to_draw_1[x][i][j][k].out_x = interpolate(lower.path[i][j][k].out_x, upper.path[i][j][k].out_x, fraction_con[x]);
                            text_path_to_draw_1[x][i][j][k].out_y = interpolate(lower.path[i][j][k].out_y - variablefont[0].typeface.parameters.ascender, upper.path[i][j][k].out_y - variablefont[0].typeface.parameters.ascender, fraction_con[x]);
                        }

                    }
                }
            }





            let fraction_con = [];

            for (let i = 0; i < Object.entries(inputVariables).length; i++){
                fraction_con[i] = (Object.entries(inputVariables)[i][1] - Object.entries(lower.variable)[i][1]) / (Object.entries(upper.variable)[i][1] - Object.entries(lower.variable)[i][1]);
            }



            let text_path_to_draw = structuredClone(lower.path);



            let test = [];

            for(let i = 0; i < fraction_con.length;i++){
                test[i] = structuredClone(lower.path);
            }



            let test_test = structuredClone(lower.path);

            for(let x = 0; x < test.length; x++){
                for (let i = 0; i < test[x].length; i++) {
                    for (let j = 0; j < test[x][i].length; j++) {
                        for (let k = 0; k < test[x][i][j].length; k++) {
                        
                            test[x][i][j][k].x = interpolate(lower.path[i][j][k].x, upper.path[i][j][k].x, fraction_con[x]);
                            test[x][i][j][k].y = interpolate(lower.path[i][j][k].y - variablefont[0].typeface.parameters.ascender, upper.path[i][j][k].y - variablefont[0].typeface.parameters.ascender, fraction_con[x]);
                            test[x][i][j][k].in_x = interpolate(lower.path[i][j][k].in_x, upper.path[i][j][k].in_x, fraction_con[x]);
                            test[x][i][j][k].in_y = interpolate(lower.path[i][j][k].in_y - variablefont[0].typeface.parameters.ascender, upper.path[i][j][k].in_y - variablefont[0].typeface.parameters.ascender, fraction_con[x]);
                            test[x][i][j][k].out_x = interpolate(lower.path[i][j][k].out_x, upper.path[i][j][k].out_x, fraction_con[x]);
                            test[x][i][j][k].out_y = interpolate(lower.path[i][j][k].out_y - variablefont[0].typeface.parameters.ascender, upper.path[i][j][k].out_y - variablefont[0].typeface.parameters.ascender, fraction_con[x]);
                        }

                    }
                }
            }



            for (let i = 0; i < test_test.length; i++) {
                for (let j = 0; j < test_test[i].length; j++) {
                    for (let k = 0; k < test_test[i][j].length; k++) {
                        
                        for(let x = 0; x < fraction_con.length; x++){
                            test_test[i][j][k].x = interpolate(lower.path[i][j][k].x, upper.path[i][j][k].x, fraction_con[x]);
                            test_test[i][j][k].y = interpolate(lower.path[i][j][k].y - variablefont[0].typeface.parameters.ascender, upper.path[i][j][k].y - variablefont[0].typeface.parameters.ascender, fraction_con[x]);
                            test_test[i][j][k].in_x = interpolate(lower.path[i][j][k].in_x, upper.path[i][j][k].in_x, fraction_con[x]);
                            test_test[i][j][k].in_y = interpolate(lower.path[i][j][k].in_y - variablefont[0].typeface.parameters.ascender, upper.path[i][j][k].in_y - variablefont[0].typeface.parameters.ascender, fraction_con[x]);
                            test_test[i][j][k].out_x = interpolate(lower.path[i][j][k].out_x, upper.path[i][j][k].out_x, fraction_con[x]);
                            test_test[i][j][k].out_y = interpolate(lower.path[i][j][k].out_y - variablefont[0].typeface.parameters.ascender, upper.path[i][j][k].out_y - variablefont[0].typeface.parameters.ascender, fraction_con[x]);
                        }

                    }
                }
            }




asdf

            for (let i = 0; i < text_path_to_draw.length; i++) {
                for (let j = 0; j < text_path_to_draw[i].length; j++) {
                    for (let k = 0; k < text_path_to_draw[i][j].length; k++) {
                        
                        for(let x = 0; x < fraction_con.length; x++){
                            text_path_to_draw[i][j][k].x = interpolate(lower.path[i][j][k].x, upper.path[i][j][k].x, fraction_con[x]);
                            text_path_to_draw[i][j][k].y = interpolate(lower.path[i][j][k].y - variablefont[0].typeface.parameters.ascender, upper.path[i][j][k].y - variablefont[0].typeface.parameters.ascender, fraction_con[x]);
                            text_path_to_draw[i][j][k].in_x = interpolate(lower.path[i][j][k].in_x, upper.path[i][j][k].in_x, fraction_con[x]);
                            text_path_to_draw[i][j][k].in_y = interpolate(lower.path[i][j][k].in_y - variablefont[0].typeface.parameters.ascender, upper.path[i][j][k].in_y - variablefont[0].typeface.parameters.ascender, fraction_con[x]);
                            text_path_to_draw[i][j][k].out_x = interpolate(lower.path[i][j][k].out_x, upper.path[i][j][k].out_x, fraction_con[x]);
                            text_path_to_draw[i][j][k].out_y = interpolate(lower.path[i][j][k].out_y - variablefont[0].typeface.parameters.ascender, upper.path[i][j][k].out_y - variablefont[0].typeface.parameters.ascender, fraction_con[x]);
                        }

                    }
                }
            }





            
            let structure_lower = structuredClone(text_package.text_structure_con[lower.index]);
            let structure_upper = structuredClone(text_package.text_structure_con[upper.index]);
            let structure_path_to_draw = structuredClone(text_package.text_structure_con[lower.index]);

            for (let i = 0; i < structure_path_to_draw.length; i++) {
                        
                for(let x = 0; x < fraction_con.length; x++){
                    structure_path_to_draw[i].base_0.x = interpolate(structure_lower[i].base_0.x, structure_upper[i].base_0.x, fraction_con[x]);
                    structure_path_to_draw[i].base_0.y = interpolate(structure_lower[i].base_0.y, structure_upper[i].base_0.y, fraction_con[x]);
                    structure_path_to_draw[i].base_1.x = interpolate(structure_lower[i].base_1.x, structure_upper[i].base_1.x, fraction_con[x]);
                    structure_path_to_draw[i].base_1.y = interpolate(structure_lower[i].base_1.y, structure_upper[i].base_1.y, fraction_con[x]);
                    structure_path_to_draw[i].point_0.x = interpolate(structure_lower[i].point_0.x, structure_upper[i].point_0.x, fraction_con[x]);
                    structure_path_to_draw[i].point_0.y = interpolate(structure_lower[i].point_0.y, structure_upper[i].point_0.y, fraction_con[x]);
                    structure_path_to_draw[i].point_1.x = interpolate(structure_lower[i].point_1.x, structure_upper[i].point_1.x, fraction_con[x]);
                    structure_path_to_draw[i].point_1.y = interpolate(structure_lower[i].point_1.y, structure_upper[i].point_1.y, fraction_con[x]);
                    structure_path_to_draw[i].point_2.x = interpolate(structure_lower[i].point_2.x, structure_upper[i].point_2.x, fraction_con[x]);
                    structure_path_to_draw[i].point_2.y = interpolate(structure_lower[i].point_2.y, structure_upper[i].point_2.y, fraction_con[x]);
                    structure_path_to_draw[i].point_3.x = interpolate(structure_lower[i].point_3.x, structure_upper[i].point_3.x, fraction_con[x]);
                    structure_path_to_draw[i].point_3.y = interpolate(structure_lower[i].point_3.y, structure_upper[i].point_3.y, fraction_con[x]);
                }

            }


            return { text_path_to_draw, structure_path_to_draw };


        }




            this.draw = function(variables){

                let total_width = sumArray(width_con);


                 // might be able to take out of draw function if scale don't change in motion
                if(assets.alignment == 'center'){
                    for(let i = 0; i < text.length; i++){
                        text_alignment = assets.position.x - (total_width / 2);
                    }
                }else if(assets.alignment == 'left'){
                    for(let i = 0; i < text.length; i++){
                        text_alignment = assets.position.x;
                    }
                }else if(assets.alignment == 'right'){
                    for(let i = 0; i < text.length; i++){
                        text_alignment = assets.position.x - total_width;
                    }
                }


                // might be able to take out of draw function if scale don't change in motion
                if(assets.sticky == 'bottom'){
                    for(let i = 0; i < text.length; i++){
                        pos_y_align[i] = - ((variablefont[0].typeface.parameters.ascender - variablefont[0].typeface.parameters.descender) * assets.scale);
                    }
                }else{
                    for(let i = 0; i < text.length; i++){
                        pos_y_align[i] = 0;
                    }
                }


                
                let text_path_to_draw = calc_test(variables).text_path_to_draw;
                let structure_path_to_draw = calc_test(variables).structure_path_to_draw;
                    

                
                ctx.beginPath();
                for (let i = 0; i < text.length; i++) {

                    for (let j = 0; j < text_path_to_draw[i].length; j++) {
                        ctx.moveTo(
                            (text_path_to_draw[i][j][0].x * assets.scale) + updated_width_con[i] + text_alignment, 
                           -(text_path_to_draw[i][j][0].y * assets.scale) + assets.position.y + pos_y_align[i]
                        );

                        for (let k = 0; k < text_path_to_draw[i][j].length - 1; k++) {
                            ctx.bezierCurveTo(
                                (text_path_to_draw[i][j][k].out_x * assets.scale) + updated_width_con[i] + text_alignment, 
                               -(text_path_to_draw[i][j][k].out_y * assets.scale) + assets.position.y + pos_y_align[i], 
                                (text_path_to_draw[i][j][k + 1].in_x * assets.scale) + updated_width_con[i] + text_alignment, 
                               -(text_path_to_draw[i][j][k + 1].in_y * assets.scale) + assets.position.y + pos_y_align[i], 
                                (text_path_to_draw[i][j][k + 1].x * assets.scale) + updated_width_con[i] + text_alignment, 
                               -(text_path_to_draw[i][j][k + 1].y * assets.scale) + assets.position.y + pos_y_align[i]
                            );
                        }

                        ctx.bezierCurveTo(
                            (text_path_to_draw[i][j][text_path_to_draw[i][j].length - 1].out_x * assets.scale) + updated_width_con[i] + text_alignment, 
                           -(text_path_to_draw[i][j][text_path_to_draw[i][j].length - 1].out_y * assets.scale) + assets.position.y + pos_y_align[i],
                            (text_path_to_draw[i][j][0].in_x * assets.scale) + updated_width_con[i] + text_alignment, 
                           -(text_path_to_draw[i][j][0].in_y * assets.scale) + assets.position.y + pos_y_align[i],
                            (text_path_to_draw[i][j][0].x * assets.scale) + updated_width_con[i] + text_alignment, 
                           -(text_path_to_draw[i][j][0].y * assets.scale) + assets.position.y + pos_y_align[i]
                        );
                    }


                }

                ctx.fillStyle = assets.color;
                ctx.fill();
                ctx.strokeStyle = assets.stroke_style;
                ctx.lineWidth = assets.stroke_width;
                ctx.stroke();
                ctx.closePath();

                

                for (let i = 0; i < text.length; i++) {

                    ctx.beginPath();
                        ctx.moveTo((structure_path_to_draw[i].point_0.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_path_to_draw[i].point_0.y * assets.scale) + assets.position.y + pos_y_align[i]);
                        ctx.lineTo((structure_path_to_draw[i].point_1.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_path_to_draw[i].point_1.y * assets.scale) + assets.position.y + pos_y_align[i]);
                        ctx.lineTo((structure_path_to_draw[i].point_2.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_path_to_draw[i].point_2.y * assets.scale) + assets.position.y + pos_y_align[i]);
                        ctx.lineTo((structure_path_to_draw[i].point_3.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_path_to_draw[i].point_3.y * assets.scale) + assets.position.y + pos_y_align[i]);
                        
                        ctx.lineTo((structure_path_to_draw[i].point_0.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_path_to_draw[i].point_0.y * assets.scale) + assets.position.y + pos_y_align[i]);

                        ctx.strokeStyle = assets.structure_style;
                        ctx.lineWidth = assets.structure_width;
                        ctx.stroke();

                        ctx.closePath();


                        ctx.beginPath();
                        ctx.moveTo((structure_path_to_draw[i].base_0.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_path_to_draw[i].base_0.y * assets.scale) + assets.position.y + pos_y_align[i]);
                        ctx.lineTo((structure_path_to_draw[i].base_1.x * assets.scale) + updated_width_con[i] + text_alignment, (structure_path_to_draw[i].base_1.y * assets.scale) + assets.position.y + pos_y_align[i]);

                        ctx.strokeStyle = assets.structure_style;
                        ctx.lineWidth = assets.structure_width;
                        ctx.stroke();

                    ctx.closePath();

                }


                for(let i = 0; i < text.length; i++){
                    width_con[i] = (structure_path_to_draw[i].point_1.x - structure_path_to_draw[i].point_0.x) * assets.scale;
                }


                // Variable to store the cumulative sum
                let cumulativeSum = 0;


                // Loop through the original array starting from index 1
                for (let i = 0; i < width_con.length; i++) {
                    cumulativeSum += width_con[i];
                    updated_width_con[i + 1] = cumulativeSum;
                }
                


                ctx.fillStyle = assets.color;
                ctx.fill();
                ctx.strokeStyle = assets.stroke_style;
                ctx.lineWidth = assets.stroke_width;
                ctx.stroke();
                ctx.closePath();


                
            }


            function sumArray(arr) {
                let sum = 0;

                for (let i = 0; i < arr.length; i++) {
                    sum += arr[i];
                }

                return sum;
            }
        

        }








        let variblefont = [{
                typeface: Neue_Haas_Grotesk_Display_Pro_15_XXThin,
                variables: {Weight: 0, Italic: 0}
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_25_XThin,
                variables: {Weight: 100, Italic: 0}
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_35_Thin,
                variables: {Weight: 200, Italic: 0}
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_45_Light,
                variables: {Weight: 300, Italic: 0}
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_55_Roman,
                variables: {Weight: 400, Italic: 0}
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_65_Medium,
                variables: {Weight: 500, Italic: 0}
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_75_Bold,
                variables: {Weight: 600, Italic: 0}
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_95_Black,
                variables: {Weight: 700, Italic: 0}
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_16_XXThin_Italic,
                variables: {Weight: 0, Italic: 100}
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_26_XThin_Italic,
                variables: {Weight: 100, Italic: 100}
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_36_Thin_Italic,
                variables: {Weight: 200, Italic: 100}
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_46_Light_Italic,
                variables: {Weight: 300, Italic: 100}
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_56_Roman_Italic,
                variables: {Weight: 400, Italic: 100}
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_66_Medium_Italic,
                variables: {Weight: 500, Italic: 100}
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_76_Bold_Italic,
                variables: {Weight: 600, Italic: 100}
            },{
                typeface: Neue_Haas_Grotesk_Display_Pro_96_Black_Italic,
                variables: {Weight: 700, Italic: 100}
            }
        ];



        let assets = {
                    position: {x: 100, y:100},
                    weight: 0,
                    scale: 0.5,
                    alignment: 'left',
                    italic: false,
                    sticky: undefined,
                    color: undefined,
                    line_height: undefined,
                    tracking: undefined,
                    kerning: undefined,
                    stroke_width: 1,
                    stroke_style: undefined,
                    structure_width: 1,
                    structure_style: undefined,
        };


        let letter_test = new VariableFontOnCanvas(variblefont, assets, 'HamburgefonstivHamburgefonstiv');


        

        let x = 0;
        function anim() {

            x = x + 1;

            ctx.beginPath();
            ctx.rect(0, 0, 1000, 1000);
            ctx.fillStyle = "#000000";
            ctx.fill();
            ctx.closePath();

            // letter_a_1.draw(0.5);

            letter_test.draw({Weight: 360 + x, Italic: 10})

            window.requestAnimationFrame(anim);


        }

        anim();




    </script>
  </body>
</html>
